package es.uma.lcc.caesium.problem.lotkavolterra.ea;



import es.uma.lcc.caesium.ea.base.Genotype;
import es.uma.lcc.caesium.ea.base.Individual;
import es.uma.lcc.caesium.ea.fitness.ContinuousObjectiveFunction;
import es.uma.lcc.caesium.ea.fitness.OptimizationSense;
import es.uma.lcc.caesium.problem.lotkavolterra.LotkaVolterra;
import es.uma.lcc.caesium.problem.lotkavolterra.LotkaVolterraTrace;


/**
 * Objective function for the parameter estimation problem in the Lotka-Volterra model.
 * Solutions are represented as the concatenation of all numerical parameters in the model,
 * namely, growth rates, self-limitation rates, and interaction coefficients (predation 
 * losses and gains).
 * @author ccottap
 * @version 1.0
 */
public class LotkaVolterraObjectiveFunction extends ContinuousObjectiveFunction {
	/**
	 * the data to fit
	 */
	private LotkaVolterraTrace lvt;
	/**
	 * the number of species
	 */
	private int n;
	/**
	 * size of the data
	 */
	private int dataSize;
	
	/**
	 * Basic constructor of the objective function
	 * @param lvt the data to fit
	 */
	public LotkaVolterraObjectiveFunction(LotkaVolterraTrace lvt) {
		super(getNumberOfParameters(lvt));
		
		this.lvt = lvt;
		n = lvt.getNumberOfSpecies();
		dataSize = lvt.size()*n;
		
		// --------------------------------------------------------------
		// TODO: define the range of each variable
		// --------------------------------------------------------------
		
	}
	
	/**
	 * Returns the number of parameters of the Lotka-Volterra model
	 * @param lvt the data to fit
	 * @return the number of parameters
	 */
	public static int getNumberOfParameters(LotkaVolterraTrace lvt) {
		// --------------------------------------------------------------
		// TODO: compute and return the number of parameters
		// --------------------------------------------------------------
		return 0;
	}

	@Override
	public OptimizationSense getOptimizationSense() {
		return OptimizationSense.MINIMIZATION;
	}
	
	/**
	 * Returns the data being fit
	 * @return the data being fit
	 */
	public LotkaVolterraTrace getProblemData () {
		return lvt;
	}
	
	
	/**
	 * Returns the Lotka-Volterra model encoded in the individual
	 * @param g the individual's genome
	 * @return the Lotka-Volterra model
	 */
	public LotkaVolterra getLotkaVolterraModel(Genotype g) {
		LotkaVolterra lv = new LotkaVolterra(n);

		// --------------------------------------------------------------
		// TODO: set the values of the parameters in the Lotka-Volterra
		//       model based on the variables in the genotype g
		// --------------------------------------------------------------

		return lv;
	}
	
	/**
	 * Evaluates a Lotka-Volterra model and returns the mean squared error with respect to the data.
	 * @param lv the Lotka-Volterra model to evaluate
	 * @param lvt the data to compare to
	 * @return the mean squared error
	 */
	public double getError (LotkaVolterra lv, LotkaVolterraTrace lvt) {
		LotkaVolterraTrace newTrace = lv.integrate(lvt.getStateAtTime(0), 
												   lvt.getMaxTime(), 
												   .5);
		// One can play with the integration step above
		
		double error = 0.0;
		
		// --------------------------------------------------------------
		// TODO: compute the mean squared error between the original data
		//       in lvt and the data generated by the model lv (newTrace)
		// --------------------------------------------------------------

		
		return error/dataSize;
	}
	
	
	@Override
	protected double _evaluate(Individual ind) {
		Genotype g = ind.getGenome();		
		LotkaVolterra lv = getLotkaVolterraModel(g);		
		return getError(lv, lvt);
	}
	
}
